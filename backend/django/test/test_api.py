from django.conf import settings

from core.management.commands.seed import (
    SEED_PROJECT, SEED_USERNAME, SEED_EMAIL,
    SEED_PASSWORD, SEED_LABELS, SEED_USERNAME2,
    SEED_PASSWORD2)
from core.pagination import SmartPagination
from core.models import Project, Profile, DataQueue, DataLabel, Data, Queue, ProjectPermissions, LabelChangeLog, Label

from test.util import read_test_data_api

from core.util import assign_datum, fill_queue, get_assignments
from django.contrib.auth import get_user_model
AuthUser = get_user_model()

# Need a hashable dict so we can put them in a set
class HashableDict(dict):
    def __hash__(self):
        return hash(frozenset(self))

def subset_keys(dict_, keys):
    '''
    Return a new HashableDict with the given subset of keys extracted from
    the given dict.
    '''
    return HashableDict([(k, dict_[k]) for k in dict_ if k in keys])


def assert_collections_equal(expected, actual):
    '''
    Determine whether two collections contain the same objects.
    '''
    for obj in expected:
        assert obj in actual

    for obj in actual:
        assert obj in expected


def compare_post_response(response, expected, significant_keys):
    '''
    Compare an HttpResponse generated by client.post(<url>, <data>)
    to an expected result.  Only fields listed in "significant_keys"
    will be considered in equality comparison.
    '''
    assert response.status_code == 201

    significant_expected = subset_keys(expected, significant_keys)
    significant_response = subset_keys(response.json(), significant_keys)

    assert significant_expected == significant_response


def compare_get_response(response, expected, significant_keys):
    '''
    Compare a django.http.HttpResponse generated by a client.get(<url>)
    to a list of expected API results.  Only fields listed in "significant_keys"
    will be considered in equality comparisons.
    '''
    assert response.status_code == 200

    response_json = response.json()

    significant_keys = set(significant_keys)

    significant_expected = set(subset_keys(d, significant_keys)
                               for d in expected)
    significant_response = set(subset_keys(d, significant_keys)
                               for d in response_json['results'])

    assert_collections_equal(significant_expected, significant_response)

def sign_in_and_fill_queue(project, test_queue, client, admin_client = None):
    fill_queue(test_queue,'random')

    if admin_client is not None:
        admin_client.login(username=SEED_USERNAME2, password=SEED_PASSWORD2)
        admin_profile = Profile.objects.get(user__username=SEED_USERNAME2)
        ProjectPermissions.objects.create(profile=admin_profile,
                                          project=project,
                                          permission='ADMIN')
    else:
        admin_profile = None
    client.login(username=SEED_USERNAME, password=SEED_PASSWORD)


    client_profile = Profile.objects.get(user__username=SEED_USERNAME)


    ProjectPermissions.objects.create(profile=client_profile,
                                      project=project,
                                      permission='CODER')

    return client_profile, admin_profile

def test_get_projects(seeded_database, admin_client):
    response = admin_client.get('/api/projects/')
    compare_get_response(response, [{ 'name': SEED_PROJECT }], ['name'])

def test_get_users(seeded_database, admin_client):
    response = admin_client.get('/api/users/')
    compare_get_response(response, [{}], [])

def test_get_auth_users(seeded_database, admin_client):
    response = admin_client.get('/api/auth_users/')
    compare_get_response(response, [
        { 'username': SEED_USERNAME, 'email': SEED_EMAIL },
        { 'username': SEED_USERNAME2, 'email': SEED_EMAIL },
        # Special user created for the admin_client to run tests
        { 'username': 'admin', 'email': 'admin@example.com' }
    ], ['username', 'email'])

def test_login(seeded_database, client, db):
    assert client.login(username=SEED_USERNAME, password=SEED_PASSWORD)

def test_get_labels(seeded_database, admin_client):
    response = admin_client.get('/api/labels/')
    compare_get_response(response, [
        { 'name': label } for label in SEED_LABELS
    ], ['name'])

def test_get_data(seeded_database, admin_client):
    expected = read_test_data_api()
    expected = [{'text': x['Text']} for x in expected]

    assert SmartPagination.max_page_size >= len(expected), \
            "SmartPagination's max_page_size setting must be larger than the " \
            "size of the sample dataset for this test to run properly."

    response = admin_client.get('/api/data/?page_size={}'.format(len(expected)))
    compare_get_response(response, expected, ['text'])

def test_get_label_history(seeded_database, admin_client, client, test_project_data, test_queue, test_labels, test_admin_queue):
    '''This tests the function that returns the elements
    that user has already labeled'''
    project = test_project_data
    client_profile, admin_profile = sign_in_and_fill_queue(project, test_queue, client, admin_client)
    #before anything has been labeled, the history table should be empty
    response = admin_client.get('/api/get_label_history/'+str(project.pk)+'/')
    assert response.json()['data'] == []

    #skip an item. Should still be empty
    data = get_assignments(client_profile, project, 2)
    datum = data[0]
    assert datum is not None
    response = client.post('/api/skip_data/'+str(datum.pk)+'/')
    assert 'error' not in response.json()

    response = client.get('/api/get_label_history/'+str(project.pk)+'/')
    assert response.json()['data'] == []

    #have one user label something. Call label history on two users.
    request_info = {
    "labelID": test_labels[0].pk,
    "labeling_time": 3
    }
    datum = data[1]
    response = client.post('/api/annotate_data/'+str(datum.pk)+'/', request_info)
    assert 'error' not in response.json()

    response_client = client.get('/api/get_label_history/'+str(project.pk)+'/')
    assert response_client.json()['data'] != []

    response_admin = admin_client.get('/api/get_label_history/'+str(project.pk)+'/')
    assert response_admin.json()['data'] == []

    #the label should be in the correct person's history
    response_data = response_client.json()['data'][0]
    assert response_data["id"] == datum.pk
    assert response_data["labelID"] == test_labels[0].pk


def test_annotate_data(seeded_database, client, test_project_data, test_queue, test_labels, test_admin_queue):
    '''This tests the basic ability to annotate a datum'''
    #get a datum from the queue
    project = test_project_data
    fill_queue(test_queue,'random')
    request_info = {
    "labelID": test_labels[0].pk,
    "labeling_time": 3
    }
    permission_message = 'Account disabled by administrator.  Please contact project owner for details'
    #call annotate data without the user having permission. Check that
    #the data is not annotated and the response has an error.
    client.login(username=SEED_USERNAME, password=SEED_PASSWORD)
    client_profile = Profile.objects.get(user__username=SEED_USERNAME)

    data = get_assignments(client_profile, project, 1)
    response = client.post('/api/annotate_data/'+str(data[0].pk)+'/', request_info)
    assert 'error' in response.json() and permission_message in response.json()['error']

    assert DataLabel.objects.filter(data=data[0]).count() == 0
    ProjectPermissions.objects.create(profile=client_profile,
                                      project=project,
                                      permission='CODER')

    #give the user permission and call annotate again
    #The data should be labeled and in the proper places
    #check that the response was {} (no error)
    response = client.post('/api/annotate_data/'+str(data[0].pk)+'/', request_info)
    assert 'error' not in response.json()
    assert DataLabel.objects.filter(data=data[0]).count() == 1
    assert DataQueue.objects.filter(data=data[0]).count() == 0

def test_skip_data(seeded_database, client, test_project_data, test_queue, test_labels, test_admin_queue):
    '''
    This tests that the skip data api works
    '''
    project = test_project_data
    fill_queue(test_queue,'random')
    permission_message = 'Account disabled by administrator.  Please contact project owner for details'
    #call skip data without the user having permission. Check that
    #the data is not in admin and the response has an error.
    client.login(username=SEED_USERNAME, password=SEED_PASSWORD)
    client_profile = Profile.objects.get(user__username=SEED_USERNAME)

    data = get_assignments(client_profile, project, 1)
    response = client.post('/api/skip_data/'+str(data[0].pk)+'/')
    assert 'error' in response.json() and permission_message in response.json()['error']

    assert DataQueue.objects.filter(data=data[0], queue = test_queue).count() == 1
    assert DataQueue.objects.filter(data=data[0], queue = test_admin_queue).count() == 0
    ProjectPermissions.objects.create(profile=client_profile,
                                      project=project,
                                      permission='CODER')

    #have someone skip something with permission. Should
    #be in admin queue, not in normal queue, not in datalabel
    response = client.post('/api/skip_data/'+str(data[0].pk)+'/')
    assert 'error' not in response.json()

    assert DataQueue.objects.filter(data=data[0], queue = test_queue).count() == 0
    assert DataQueue.objects.filter(data=data[0], queue = test_admin_queue).count() == 1
    assert DataLabel.objects.filter(data=data[0]).count() == 0

def test_modify_label(seeded_database, client, test_project_data, test_queue, test_labels, test_admin_queue):
    '''
    This tests the history table's ability to modify a label
    '''
    request_info = {
    "labelID": test_labels[0].pk,
    "labeling_time": 3
    }
    project = test_project_data
    client_profile, admin_profile = sign_in_and_fill_queue(project, test_queue, client)
    #have a user annotate some data
    data = get_assignments(client_profile, project, 1)[0]
    assert data is not None
    response = client.post('/api/annotate_data/'+str(data.pk)+'/', request_info)
    assert DataLabel.objects.filter(data=data).count() == 1
    #call modify label to change it to the same thing
    change_info = {
    "dataID": data.pk,
    "oldLabelID": test_labels[0].pk,
    "labelID": test_labels[0].pk
    }
    response = client.post('/api/modify_label/'+str(data.pk)+'/',change_info).json()
    assert response != {}
    #check that there is an error
    assert 'error' in response and 'Invalid. The new label should be different' in response['error']
    #call modify label to change it to something else
    change_info = {
    "dataID": data.pk,
    "oldLabelID": test_labels[0].pk,
    "labelID": test_labels[1].pk
    }
    response = client.post('/api/modify_label/'+str(data.pk)+'/',change_info)
    assert 'error' not in response.json()
    #check that the label is updated and it's in the correct places
    #check that there are no duplicate labels
    assert DataLabel.objects.filter(data=data).count() == 1
    assert DataLabel.objects.get(data=data).label.pk == test_labels[1].pk
    #check it's in change log
    assert LabelChangeLog.objects.filter(data=data).count() == 1

def test_modify_label_to_skip(seeded_database, client, test_project_data, test_queue, test_labels, test_admin_queue):
    '''This tests the history table's ability to change labeled items
    to skipped items.'''
    request_info = {
    "labelID": test_labels[0].pk,
    "labeling_time": 3
    }
    project = test_project_data
    client_profile, admin_profile = sign_in_and_fill_queue(project, test_queue, client)
    #have a user annotate some data
    data = get_assignments(client_profile, project, 1)[0]
    assert data is not None
    response = client.post('/api/annotate_data/'+str(data.pk)+'/', request_info)
    assert DataLabel.objects.filter(data=data).count() == 1

    #Call the change to skip function. Should now be in admin table, not be
    #in history table.
    change_info = {
    "dataID": data.pk,
    "oldLabelID": test_labels[0].pk
    }
    response = client.post('/api/modify_label_to_skip/'+str(data.pk)+'/', change_info)
    assert 'error' not in response.json()

    assert DataLabel.objects.filter(data=data).count() == 0
    assert DataQueue.objects.filter(queue=test_admin_queue).count() == 1
    #check it's in change log
    assert LabelChangeLog.objects.filter(data=data,new_label="skip").count() == 1

def test_skew_label(seeded_database, admin_client, client, test_project_data, test_queue, test_labels, test_admin_queue):
    '''
    This tests the skew label functionalty, which takes unlabeled and
    unnasigned data and labels it.
    '''
    request_info = {
    "labelID": test_labels[0].pk,
    "labeling_time": 3
    }
    project = test_project_data
    admin_client.login(username=SEED_USERNAME2, password=SEED_PASSWORD2)
    admin_profile = Profile.objects.get(user__username=SEED_USERNAME2)
    ProjectPermissions.objects.create(profile=admin_profile,
                                          project=project,
                                          permission='ADMIN')
    client.login(username=SEED_USERNAME, password=SEED_PASSWORD)
    client_profile = Profile.objects.get(user__username=SEED_USERNAME)
    ProjectPermissions.objects.create(profile=client_profile,
                                      project=project,
                                      permission='CODER')


    #have a regular coder try and label things. Should not be allowed.
    data = Data.objects.filter(project=project)[0]
    assert data is not None
    response = client.post('/api/label_skew_label/'+str(data.pk)+'/', request_info)
    assert 'error' in response.json() and "Invalid permission. Must be an admin." in response.json()['error']
    #have an admin try and label. Should be allowed.
    response = admin_client.post('/api/label_skew_label/'+str(data.pk)+'/', request_info)
    assert 'error' not in response.json()
    assert DataLabel.objects.filter(data=data).count() == 1

def test_admin_label(seeded_database, admin_client, client, test_project_data, test_queue, test_labels, test_admin_queue):
    '''
    This tests the admin ability to label skipped items in the admin table
    '''
    #fill queue. The admin queue should be empty
    project = test_project_data
    client_profile, admin_profile = sign_in_and_fill_queue(project, test_queue, client, admin_client)
    assert DataQueue.objects.filter(queue=test_admin_queue).count() == 0
    #have a normal client skip something and try to admin label. Should not
    #be allowed
    data = get_assignments(client_profile, project, 1)[0]
    response = client.post('/api/skip_data/'+str(data.pk)+'/')
    assert 'error' not in response.json()

    payload = {'labelID':test_labels[0].pk}
    response = client.post('/api/label_admin_label/'+str(data.pk)+'/',payload)

    assert 'error' in response.json() and "Invalid permission. Must be an admin." in response.json()['error']

    #check datum is in proper places
    assert DataQueue.objects.filter(data=data, queue=test_admin_queue).count() == 1
    assert DataQueue.objects.filter(data=data, queue=test_queue).count() == 0
    assert DataLabel.objects.filter(data=data).count() == 0


    #Let admin label datum. Should work. Check it is now in proper places
    response = admin_client.post('/api/label_admin_label/'+str(data.pk)+'/',payload)
    assert 'error' not in response.json()
    assert DataQueue.objects.filter(data=data, queue=test_admin_queue).count() == 0
    assert DataLabel.objects.filter(data=data).count() == 1

def test_label_distribution(seeded_database, admin_client, client, test_project_data, test_queue, test_labels, test_admin_queue):
    '''
    This tests the api that produces the label counts chart
    for the admin page
    '''
    project = test_project_data
    client_profile, admin_profile = sign_in_and_fill_queue(project, test_queue, client, admin_client)

    #at the beginning, should return empty list
    response = client.get('/api/label_distribution/'+str(project.pk)+'/')
    assert len(response.json()) == 0

    #have client label three things differently. Check values.
    data = get_assignments(client_profile, project, 3)
    response = client.post('/api/annotate_data/'+str(data[0].pk)+'/',{
    "labelID": test_labels[0].pk, "labeling_time": 3
    })
    response = client.post('/api/annotate_data/'+str(data[1].pk)+'/',{
    "labelID": test_labels[1].pk, "labeling_time": 3
    })
    response = client.post('/api/annotate_data/'+str(data[2].pk)+'/',{
    "labelID": test_labels[2].pk, "labeling_time": 3
    })
    assert DataLabel.objects.filter(data__in=data).count() == 3

    response = client.get('/api/label_distribution/'+str(project.pk)+'/').json()
    assert len(response) > 0

    for row in response:
        temp_dict = row['values']
        for label_dict in temp_dict:
            assert label_dict['x'] in [str(admin_profile),str(client_profile), 'test_profile']
            if label_dict['x'] == str(admin_profile) or label_dict['x'] == 'test_profile':
                assert label_dict['y'] == 0
            else:
                assert label_dict['y'] == 1

    #Have admin label three things the same. Check values.
    data = get_assignments(admin_profile, project, 3)
    response = admin_client.post('/api/annotate_data/'+str(data[0].pk)+'/',{
    "labelID": test_labels[0].pk, "labeling_time": 3
    })
    response = admin_client.post('/api/annotate_data/'+str(data[1].pk)+'/',{
    "labelID": test_labels[0].pk, "labeling_time": 3
    })
    response = admin_client.post('/api/annotate_data/'+str(data[2].pk)+'/',{
    "labelID": test_labels[0].pk, "labeling_time": 3
    })

    response = client.get('/api/label_distribution/'+str(project.pk)+'/').json()
    assert len(response) > 0

    for row in response:
        label = row['key']
        temp_dict = row['values']
        for label_dict in temp_dict:
            assert label_dict['x'] in [str(admin_profile),str(client_profile), 'test_profile']
            if label_dict['x'] == str(admin_profile):
                if label == test_labels[0].name:
                    assert label_dict['y'] == 3
                else:
                    assert label_dict['y'] == 0
            elif label_dict['x'] == 'test_profile':
                assert label_dict['y'] == 0
            else:
                assert label_dict['y'] == 1


def test_label_distribution_inverted(seeded_database, admin_client, client, test_project_data, test_queue, test_labels, test_admin_queue):
    '''
    This tests the api that produces the label counts chart for
    the skew page. It is stacked differently than the previous.
    '''
    project = test_project_data
    client_profile, admin_profile = sign_in_and_fill_queue(project, test_queue, client, admin_client)

    #at the beginning, should return empty list
    response = client.get('/api/label_distribution/'+str(project.pk)+'/')
    assert len(response.json()) == 0

    #have client label three things differently. Check values.
    data = get_assignments(client_profile, project, 3)
    response = client.post('/api/annotate_data/'+str(data[0].pk)+'/',{
    "labelID": test_labels[0].pk, "labeling_time": 3
    })
    response = client.post('/api/annotate_data/'+str(data[1].pk)+'/',{
    "labelID": test_labels[1].pk, "labeling_time": 3
    })
    response = client.post('/api/annotate_data/'+str(data[2].pk)+'/',{
    "labelID": test_labels[2].pk, "labeling_time": 3
    })
    assert DataLabel.objects.filter(data__in=data).count() == 3

    response = client.get('/api/label_distribution_inverted/'+str(project.pk)+'/').json()
    assert len(response) > 0

    for row in response:
        user = row['key']
        temp_dict = row['values']
        for label_row in temp_dict:
            if user == str(client_profile):
                assert label_row['y'] == 1
            else:
                assert user in [str(admin_profile), 'test_profile']
                assert label_row['y'] == 0

    #Have admin label three things the same. Check values.
    data = get_assignments(admin_profile, project, 3)
    response = admin_client.post('/api/annotate_data/'+str(data[0].pk)+'/',{
    "labelID": test_labels[0].pk, "labeling_time": 3
    })
    response = admin_client.post('/api/annotate_data/'+str(data[1].pk)+'/',{
    "labelID": test_labels[0].pk, "labeling_time": 3
    })
    response = admin_client.post('/api/annotate_data/'+str(data[2].pk)+'/',{
    "labelID": test_labels[0].pk, "labeling_time": 3
    })

    response = client.get('/api/label_distribution_inverted/'+str(project.pk)+'/').json()
    assert len(response) > 0

    for row in response:
        user = row['key']
        temp_dict = row['values']
        for label_row in temp_dict:
            if user == str(client_profile):
                assert label_row['y'] == 1
            elif user == str(admin_profile):
                if label_row['x'] == test_labels[0].name:
                    assert label_row['y'] == 3
                else:
                    assert label_row['y'] == 0
            else:
                assert label_row['y'] == 0

def test_label_timing(seeded_database, admin_client, client, test_project_data, test_queue, test_labels, test_admin_queue):
    #test that it starts out empty
    project = test_project_data
    client_profile = sign_in_and_fill_queue(project, test_queue, client)[0]

    response = client.get('/api/label_timing/'+str(project.pk)+'/').json()
    assert len(response['data']) == 0
    assert response['yDomain'] == 0
    #have the client label three data with time=1
    data = get_assignments(client_profile, project, 3)
    response = client.post('/api/annotate_data/'+str(data[0].pk)+'/',{
    "labelID": test_labels[0].pk, "labeling_time": 1
    })
    response = client.post('/api/annotate_data/'+str(data[1].pk)+'/',{
    "labelID": test_labels[1].pk, "labeling_time": 1
    })
    response = client.post('/api/annotate_data/'+str(data[2].pk)+'/',{
    "labelID": test_labels[2].pk, "labeling_time": 1
    })

    #check that the quartiles are all the same
    response = client.get('/api/label_timing/'+str(project.pk)+'/').json()
    assert len(response['data']) == 1

    quarts = response['data'][0]['values']
    assert quarts['Q1'] == 1 and quarts['Q2'] == 1 and quarts['Q3'] == 1
    assert quarts['whisker_low'] == 1 and quarts['whisker_high'] == 1
    assert response['yDomain'] == 11

    #have the client label three data with 0, 3, 10. Check quartiles
    data = get_assignments(client_profile, project, 3)
    response = client.post('/api/annotate_data/'+str(data[0].pk)+'/',{
    "labelID": test_labels[0].pk, "labeling_time": 0
    })
    response = client.post('/api/annotate_data/'+str(data[1].pk)+'/',{
    "labelID": test_labels[1].pk, "labeling_time": 3
    })
    response = client.post('/api/annotate_data/'+str(data[2].pk)+'/',{
    "labelID": test_labels[2].pk, "labeling_time": 10
    })

    response = client.get('/api/label_timing/'+str(project.pk)+'/').json()
    assert len(response['data']) == 1

    quarts = response['data'][0]['values']
    assert quarts['Q1'] == 1 and quarts['Q2'] == 1 and quarts['Q3'] == 3
    assert quarts['whisker_low'] == 0 and quarts['whisker_high'] == 10
    assert response['yDomain'] == 20

    #have a client label with t=100. Check quartiles.
    data = get_assignments(client_profile, project, 1)
    response = client.post('/api/annotate_data/'+str(data[0].pk)+'/',{
    "labelID": test_labels[0].pk, "labeling_time": 100
    })
    response = client.get('/api/label_timing/'+str(project.pk)+'/').json()
    quarts = response['data'][0]['values']
    assert quarts['Q1'] == 1 and quarts['Q2'] == 1 and quarts['Q3'] == 10
    assert quarts['whisker_low'] == 0 and quarts['whisker_high'] == 100
    assert response['yDomain'] == 110


'''
def test_model_metrics():

def test_coded_table():

def test_predicted_table():

def test_unlabeled_table():

def test_admin_table():

def test_change_log_table():



'''
